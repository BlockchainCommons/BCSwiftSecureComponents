import XCTest
import BCSecureComponents
import WolfBase

fileprivate let chapterNumber = 7

final class EnvelopeTestVectors: XCTestCase {
    func testGenerateEnvelopeTestVectors() throws {
        let helloWorld = TestCase(
            name: "Hello, World!",
            explanation: "The simplest case: encoding a plaintext string as the envelope's `subject`. The `subject` can be any CBOR-encodable structure.",
            envelope: Envelope(plaintextHello)
        )
        
        let signedPlaintext = TestCase(
            name: "Signed Plaintext",
            explanation: "A string has been signed by Alice.",
            envelope: Envelope(plaintextHello)
                .sign(with: alicePrivateKeys, randomGenerator: generateFakeRandomNumbers)
        )
        
        let multisignedPlaintext = TestCase(
            name: "Multisigned Plaintext",
            explanation: "Alice and Carol jointly send a signed plaintext message to Bob.",
            envelope: Envelope(plaintextHello)
                .sign(with: [alicePrivateKeys, carolPrivateKeys], randomGenerator: generateFakeRandomNumbers)
        )
        
        let symmetricEncryption = TestCase(
            name: "Symmetric Encryption",
            explanation: "Alice and Bob have agreed to use a symmetric key.",
            envelope: try Envelope(plaintextHello)
                .encrypt(with: symmetricKey, nonce: fakeNonce)
        )
        
        let signThenEncrypt = TestCase(
            name: "Sign Then Encrypt",
            explanation: "A message is first signed, then encrypted. Its signature can only be checked once the envelope is decrypted.",
            envelope: try Envelope(plaintextHello)
                .sign(with: alicePrivateKeys, randomGenerator: generateFakeRandomNumbers)
                .enclose()
                .encrypt(with: symmetricKey, nonce: fakeNonce)
        )

        let testCases = [helloWorld, signedPlaintext, multisignedPlaintext, symmetricEncryption, signThenEncrypt]
            .enumerated().map {
                var testCase = $0.1
                testCase.index = $0.0 + 1
                return testCase
            }
        
        let text = formatDocument(chapterNumber: chapterNumber, testCases: testCases)
        writeDocFile(tocFilename(at: chapterNumber), text)
    }

    @StringBuilder
    private func formatDocument(chapterNumber: Int, testCases: [TestCase]) -> String {
        documentHeader("Envelope Test Vectors")
        
        formatTableOfContents(itemIndex: chapterNumber)

        header2("Introduction")
        
        paragraph("This document provides test vectors for `crypto-envelope`. It is generated by `EnvelopeTestVectors.testGenerateEnvelopeTestVectors()` in the `BCSwiftSecureComponents` test suite.")

        header2("Status")

        paragraph("This document is a draft with a reference implementation in [BCSwiftSecureComponents](https://github.com/blockchaincommons/BCSwiftSecureComponents).")
        
        divider()
        
        paragraph("These test vectors use these fixed seed values, from which other key pairs are derived:")
        
        list([
            "Alice's Seed: `\(aliceSeed.data.hex)`",
            "Bob's Seed: `\(bobSeed.data.hex)`",
            "Carol's Seed: `\(carolSeed.data.hex)`",
            "Symmetric Key: `\(symmetricKey.data.hex)`",
        ])

        formatIndex(testCases)
        
        testCases.map {
            $0.format()
        }.joined(separator: "\n")
    }

    struct TestCase {
        var index: Int
        var name: String
        var explanation: String
        var envelope: Envelope
        
        init(index: Int = 0, name: String, explanation: String, envelope: Envelope) {
            self.index = index
            self.name = name
            self.explanation = explanation
            self.envelope = envelope
        }
        
        var title: String {
            "TEST VECTOR \(index): \(name)"
        }
        
        @StringBuilder
        func format() -> String {
            header2(title)
            
            paragraph(explanation)
            
            header3("Payload")

            note("In Envelope Notation.")
            monospaced(envelope.format)
            
            header3("UR")
            note("The CBOR in a UR is never tagged, because the UR `type` field serves this purpose.")
            monospaced(envelope.urâ€ )
            
            header3("Tagged CBOR Binary")
            monospaced(envelope.taggedCBOR.hex)
            
            header3("Tagged CBOR Diagnostic Notation")
            monospaced(envelope.taggedCBOR.diagAnnotated)
            
            header3("Tagged CBOR Annotated Binary")
            monospaced(envelope.taggedCBOR.dump)
            
            divider()
        }
    }

    func formatIndex(_ testCases: [TestCase]) -> String {
        var result = [
            header2("INDEX"),
        ]
        let items = testCases.map { link($0.name, localLink(for: $0.title)) }
        result.append(numberedList(items))
        result.append(divider())
        return result.joined(separator: "\n")
    }
}
