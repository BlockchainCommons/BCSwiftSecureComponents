import XCTest
import BCSecureComponents
import WolfBase

fileprivate let chapterNumber = 8

fileprivate let seedPayload: Seed = {
    var seed = Seed(data: ‡"59f2293a5bce7d4de59e71b4207ac5d2")!
    seed.name = "Dark Purple Aqua Love"
    seed.creationDate = try! Date(iso8601: "2021-02-24")
    seed.note = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
    return seed
}()

fileprivate let stringPayload = "It is the unspoken ethic of all magicians to not reveal the secrets. -- David Copperfield"

fileprivate protocol AnyTestCase {
    var index: Int { get set }
    var name: String { get }
    var title: String { get }
    func format() -> String
}

extension AnyTestCase {
    var title: String {
        "TEST VECTOR \(index): \(name)"
    }
}

final class SSKREnvelopeTestVectors: XCTestCase {
    func testGenerateSSKREnvelopeTestVectors() throws {
        let testCase1 = try TestCase(
            name: "Seed 2 of 3",
            payload: seedPayload,
            groupThreshold: 1,
            groups: [(2, 3)],
            recoveredShareIndexes: [0, 2],
            expectedFirstShare: "ur:crypto-envelope/lftpdylrhdprayfevdfmyaioutghbycxkpdynngmimcnzclaghbnskdeoycxeetigelultvlplfetnotsfamfpueeyluaykbsbweryvywkatsfattdpshdahbecyhpsrrlossabydkgutnmteecsaojodaloghiatkynosdydpjkctgeswuolyvaecptfzwygdbbnsswfgahqdrdfmuyhelpzmmsynrsttgdgtistsadbybtcalphsntgalacpbzwelkwlfldrynselegduowdkptsrlamnnrpiemuonfssgktloteidtkneckbaztktnndelrgouehtdngopyrdcnldhgrtlntybadypainvyaxcypagsgtkshfhdwfjzcpzohtweftrtgdnsosoxenhebdmnmycmrnnysetepatdayhddktpethdcxaygrjzeeguftwpianbtlfmpkeyjepylnhdosktgelpleielnrnpllafmrdmdflsblftpehtpfntpframtpehtpfntaadechddapduoaeadaefltivlttcloxssbnadahlsbdghcmcwuyatwnjliomwtkvaflztlnghfhfeplnthkwlpmlgqd"
        )
        
        let testCase2 = try TestCase(
            name: "String 3 of 5 with Additional Assertion",
            payload: stringPayload,
            groupThreshold: 1,
            groups: [(3, 5)],
            recoveredShareIndexes: [0, 2, 4],
            vendorNote: "This could be vendor-specific data attached to the envelope.",
            expectedFirstShare: "ur:crypto-envelope/lstpdylrhdhpptcalfwytahyyllngsjpgruemtjsztsnvlhebycscxnetsldfltehejkvyrtrdjntswnsgflkosacnmoahkpmklkrozoregawscelrrkesbdbaemhdmeoloelthddifesfldjsayckeyimtshkdyvovlwnetdkendeasmttkluzscxonfgyngygsgtkshfhdwfjzcpzohtweftrtgdgtwsfdzcattabtlyptoevsdtleeyfncyhddktpethdcxpdnecmfmzchgaedppackpandielkfpzospynvtckjlhdatonweswceuyaxvehffrlftpehtpfntpfraatpehtpfnksfnghisinjkcxiajlkpjziecxidihcxkoihjtiejljpdpjkjoihiainiyiniacxiehsjyhscxhsjyjyhsiaisihiecxjyjlcxjyisihcxihjtkoihjzjljoihdmlftpehtpfntpframtpehtpfntaadechddapduoaeaoaetkvsvakiaxzsqzchjpkktlgamnknuopdtkvsvakiaxzsqzchjpkktlgamnknuopdkpssrops"
        )
        
        let testCase3 = try TestCase(
            name: "Seed 2-of-3 of 2-of-3",
            payload: seedPayload,
            groupThreshold: 2,
            groups: [(2, 3), (2, 3), (2, 3)],
            recoveredShareIndexes: [0, 1, 6, 7],
            expectedFirstShare: "ur:crypto-envelope/lftpdylrhdprayfevdfmyaioutghbycxkpdynngmimcnzclaghbnskdeoycxeetigelultvlplfetnotsfamfpueeyluaykbsbweryvywkatsfattdpshdahbecyhpsrrlossabydkgutnmteecsaojodaloghiatkynosdydpjkctgeswuolyvaecptfzwygdbbnsswfgahqdrdfmuyhelpzmmsynrsttgdgtistsadbybtcalphsntgalacpbzwelkwlfldrynselegduowdkptsrlamnnrpiemuonfssgktloteidtkneckbaztktnndelrgouehtdngopyrdcnldhgrtlntybadypainvyaxcypagsgtkshfhdwfjzcpzohtweftrtgdnsosoxenhebdmnmycmrnnysetepatdayhddktpethdcxaygrjzeeguftwpianbtlfmpkeyjepylnhdosktgelpleielnrnpllafmrdmdflsblftpehtpfntpframtpehtpfntaadechddapduobgadaehsjklgrevenybbimhfnyrtfrgakoueindpdpweetoyfhadfshliyjlihtoptasjewnldurkk"
        )
        
        let testCases: [AnyTestCase] = [testCase1 as AnyTestCase, testCase2, testCase3]
            .enumerated().map {
                var testCase = $0.1
                testCase.index = $0.0 + 1
                return testCase
            }

        let text = formatDocument(chapterNumber: chapterNumber, testCases: testCases)
        writeDocFile(tocFilename(at: chapterNumber), text)
    }

    @StringBuilder
    private func formatDocument(chapterNumber: Int, testCases: [AnyTestCase]) -> String {
        documentHeader("Envelope SSKR Test Vectors")

        formatTableOfContents(itemIndex: chapterNumber)

        header2("Introduction")

        paragraph("This document provides test vectors for scenarios where `crypto-envelope` is used with SSKR to shard and recover secrets of any size. It is generated by `SSKREnvelopeTestVectors.testGenerateSSKREnvelopeTestVectors()` in the `BCSwiftSecureComponents` test suite.")

        header2("Status")

        paragraph("This document is a draft with a reference implementation in [BCSwiftSecureComponents](https://github.com/blockchaincommons/BCSwiftSecureComponents).")
        
        divider()

        paragraph("These objects are normally random, but they are fixed for these test vectors:")
        list([
            "Symmetric key used for encryption: `\(fakeContentKey.data.hex)`",
            "Nonce for encryption: `\(fakeNonce.data.hex)`",
            "Random generator for SSKR returns repeating sequence: `\(fakeRandomGeneratorSeed.hex)`"
        ])

        formatIndex(testCases)

        testCases.map {
            $0.format()
        }.joined(separator: "\n")
    }
    
    struct TestCase<T: CBORCodable>: AnyTestCase {
        var index: Int
        var name: String
        var payload: T
        var groupThreshold: Int
        var groups: [(Int, Int)]
        var recoveredShareIndexes: Set<Int>
        var vendorNote: String?
        var expectedFirstShare: String
        var envelopeWithPayload: Envelope!
        var groupedShares: [[Envelope]]!
        
        init(index: Int = 0, name: String, payload: T, groupThreshold: Int, groups: [(Int, Int)], recoveredShareIndexes: Set<Int>, vendorNote: String? = nil, expectedFirstShare: String) throws {
            self.index = index
            self.name = name
            self.payload = payload
            self.groupThreshold = groupThreshold
            self.groups = groups
            self.recoveredShareIndexes = recoveredShareIndexes
            self.vendorNote = vendorNote
            self.expectedFirstShare = expectedFirstShare

            // Enclose the payload in an envelope.
            self.envelopeWithPayload = Envelope(payload)
            if let vendorNote {
                envelopeWithPayload = envelopeWithPayload.add(.note, vendorNote)
            }

            self.groupedShares = try generateShares()

            try XCTAssertEqual(UR(urString: expectedFirstShare), groupedShares.first!.first!.ur)

            let recoveredShares = groupedShares.flatMap { $0 }.enumerated().compactMap { index, share in
                recoveredShareIndexes.contains(index) ? share : nil
            }
    
            let recoveredPayload = try recoverPayload(recoveredShares: recoveredShares)
            XCTAssertEqual(payload.cbor, recoveredPayload.cbor)
        }

        func recoverPayload(recoveredShares: [Envelope]) throws -> T {
            // Use SSKR to join the shares into the original envelope. If the shares are not
            // valid, an exception will be thrown.
            let joinedEnvelope = try Envelope(shares: recoveredShares)
            
            // Extract the original payload from the envelope.
            return try joinedEnvelope.extract(T.self)
        }

        func generateShares() throws -> [[Envelope]] {
            let fakeRandomGenerator = makeFakeRandomGenerator()
            
            // Encrypt the envelope with the content key. This is the key that will be split below using SSKR.
            let encryptedEnvelope = try envelopeWithPayload.encrypt(with: fakeContentKey, testNonce: fakeNonce)
            
            // Split the encrypted envelope into shares.
            let shares = encryptedEnvelope.split(
                groupThreshold: groupThreshold,
                groups: groups,
                contentKey: fakeContentKey,
                testRandomGenerator: {
                    fakeRandomGenerator.data(count: $0)
                }
            )
            
            return shares
        }

        @StringBuilder
        func format() -> String {
            header2("TEST VECTOR \(index): \(name)")

            header3("Payload in CBOR Diagnostic Notation")
            monospaced(payload.cbor.diagAnnotated)

            header3("Payload Enclosed in Envelope")
            monospaced(envelopeWithPayload.format)
            
            formatShares()
        }
        
        func formatShares() -> String {
            groupedShares.enumerated().map { groupIndex, shares -> String in
                shares.enumerated().map { shareIndex, share -> String in
                    formatShare(share, groupIndex: groupIndex, shareIndex: shareIndex)
                }.joined(separator: "\n")
            }.joined(separator: "\n")
        }

        @StringBuilder
        func formatShare(_ share: Envelope, groupIndex: Int, shareIndex: Int) -> String {
            header3("GROUP \(groupIndex + 1) SHARE \(shareIndex + 1)")
            
            header4("UR")
            note("The CBOR in a UR is never tagged, because the UR `type` field serves this purpose.")
            monospaced(share.ur†)
            
            header4("Tagged CBOR Binary")
            monospaced(share.taggedCBOR.hex)
            header4("Tagged CBOR Diagnostic Notation")
            monospaced(share.taggedCBOR.diagAnnotated)
            header4("Tagged CBOR Annotated Binary")
            monospaced(share.taggedCBOR.dump)
            divider()
        }
    }

    private func formatIndex(_ testCases: [AnyTestCase]) -> String {
        var result = [
            header2("INDEX"),
        ]
        let items = testCases.map { link($0.name, localLink(for: $0.title)) }
        result.append(numberedList(items))
        result.append(divider())
        return result.joined(separator: "\n")
    }
}
